<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>InSight AI ‚Äì Chatbox</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- T√°ch CSS ra file ri√™ng -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="app" id="app-root">
    <!-- Sidebar conversation list -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">Cu·ªôc h·ªôi tho·∫°i</div>
            <button class="new-conv-btn" id="new-conv-btn">New chat
            </button>
        </div>
        <div id="conv-list" class="conv-list">
            <!-- JS s·∫Ω render danh s√°ch conversation v√†o ƒë√¢y -->
        </div>
        <div class="sidebar-footer">
            <div class="sidebar-footer-text">
                L·ªãch s·ª≠ ƒë∆∞·ª£c l∆∞u theo t·ª´ng cu·ªôc h·ªôi tho·∫°i. B·∫•m v√†o ƒë·ªÉ xem l·∫°i.
            </div>
            <button class="logout-btn" id="logout-btn">ƒêƒÉng xu·∫•t</button>
        </div>
    </aside>

    <!-- Main chat -->
    <main class="main">
        <header class="main-header">
            <div class="title-block">
                <!-- D√πng SVG inline data-URL l√†m logo t·∫°m n·∫øu file ·∫£nh kh√¥ng t·ªìn t·∫°i -->
                <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='40' height='40'><rect width='100%25' height='100%25' fill='%2366a3ff'/><text x='50%25' y='50%25' font-size='16' fill='white' dominant-baseline='middle' text-anchor='middle'>IA</text></svg>" class="avatar-img" alt="Logo">
                <div>
                    <div class="app-name">InSight AI</div>
                    <div class="app-desc">Chatbox ph√¢n t√≠ch n·ªôi dung & h·ªó tr·ª£ b·∫°n hi·ªÉu th√¥ng tin s√¢u h∆°n.</div>
                </div>
            </div>
            <div class="header-actions">
                <!-- Ph√≥ng to / thu nh·ªè (·∫©n/hi·ªán sidebar) -->
                <button id="toggle-layout" class="header-icon-btn" title="Ph√≥ng to / thu nh·ªè chat">
                    ‚§¢
                </button>
            </div>
        </header>

        <section class="chat-area">
            <div id="messages" class="messages"></div>
            <div id="status" class="status-bar"></div>

            <div class="input-area">
                <div class="input-row">
                    <div class="input-box">
                        <textarea id="message-input" rows="1" aria-label="N·ªôi dung c·∫ßn ki·ªÉm tra"
                                  placeholder="D√°n ƒëo·∫°n tin ho·∫∑c b√†i b√°o ti·∫øng Vi·ªát ƒë·ªÉ ki·ªÉm tra Fake/Real... (Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng)"></textarea>
                        <div class="input-actions">
                            <input type="file" id="file-input" accept=".docx" style="display:none">
                            <button type="button" class="icon-btn" id="attach-btn" title="T·∫£i l√™n .docx">
                                üìé
                            </button>
                        </div>
                    </div>
                    <button class="send-btn" id="send-btn">Ph√¢n t√≠ch</button>
                </div>
            </div>
        </section>
    </main>

    <!-- Toast -->
    <div id="toast" class="toast"></div>

    <!-- Modal x√°c nh·∫≠n x√≥a -->
    <div id="confirm-modal" class="modal-backdrop">
        <div class="modal">
            <div class="modal-title">X√≥a cu·ªôc h·ªôi tho·∫°i?</div>
            <div class="modal-text">
                B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô ƒëo·∫°n chat n√†y? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.
            </div>
            <div class="modal-actions">
                <button id="confirm-cancel" class="btn-secondary">H·ªßy</button>
                <button id="confirm-ok" class="btn-danger">ƒê·ªìng √Ω</button>
            </div>
        </div>
    </div>
</div>

<script>
    // ===== L·∫•y c√°c element =====
    const appRoot      = document.getElementById('app-root');
    const messagesDiv  = document.getElementById('messages');
    const statusDiv    = document.getElementById('status');
    const messageInput = document.getElementById('message-input');
    const sendBtn      = document.getElementById('send-btn');
    const fileInput    = document.getElementById('file-input');
    const attachBtn    = document.getElementById('attach-btn');
    const convListEl   = document.getElementById('conv-list');
    const newConvBtn   = document.getElementById('new-conv-btn');
    const logoutBtn    = document.getElementById('logout-btn');
    const toastEl      = document.getElementById('toast');
    const toggleLayoutBtn = document.getElementById('toggle-layout');

    const confirmModal   = document.getElementById('confirm-modal');
    const confirmCancel  = document.getElementById('confirm-cancel');
    const confirmOk      = document.getElementById('confirm-ok');
    let pendingDeleteId  = null;

    // ===== User login t·ª´ localStorage =====
    const savedUser = localStorage.getItem("insight_user");
    let userId = null;

    if (savedUser) {
        try {
            const u = JSON.parse(savedUser);
            userId = u.id;
        } catch (e) {
            console.error("L·ªói parse insight_user:", e);
        }
    }

    if (!userId) {
        // N·∫øu ch∆∞a c√≥ user trong localStorage th√¨ t·∫°o 1 user t·∫°m (guest) ƒë·ªÉ v√†o th·∫≥ng trang ch√≠nh
        userId = 'guest';
        try {
            localStorage.setItem('insight_user', JSON.stringify({ id: userId, username: 'Kh√°ch' }));
            console.info('T·∫°o user t·∫°m (guest) trong localStorage ƒë·ªÉ v√†o th·∫≥ng trang ch√≠nh.');
        } catch (e) {
            console.warn('Kh√¥ng th·ªÉ l∆∞u insight_user v√†o localStorage:', e);
        }
    }

    // ===== State =====
    let conversationId = null;
    let conversations = [];   // danh s√°ch cu·ªôc h·ªôi tho·∫°i (sidebar)

    // ===== Helper: Toast =====
    function showToast(message, type = 'error') {
        toastEl.textContent = message;
        toastEl.classList.remove('error', 'success');
        if (type === 'success') toastEl.classList.add('success');
        else toastEl.classList.add('error');

        toastEl.classList.add('show');
        setTimeout(() => {
            toastEl.classList.remove('show');
        }, 2500);
    }

    // ===== Helper: format time & messages =====
    function formatTime(isoString) {
        if (!isoString) return '';
        const d = new Date(isoString);
        if (isNaN(d.getTime())) return '';
        return d.toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'});
    }

    function addMessage(sender, text, extra = {}) {
        const row = document.createElement('div');
        const isUser = sender.toUpperCase() === 'USER';
        row.classList.add('message-row', isUser ? 'user' : 'model');

        const bubble = document.createElement('div');
        bubble.classList.add('message-bubble');
        bubble.textContent = text;

        row.appendChild(bubble);

        // Th√¥ng tin verdict/score cho AI
        if (!isUser && (extra.verdict || extra.score)) {
            const extraDiv = document.createElement('div');
            extraDiv.className = 'model-extra';

            if (extra.verdict) {
                const badge = document.createElement('span');
                badge.classList.add('badge');
                if (extra.verdict === 'FAKE') badge.classList.add('badge-fake');
                else if (extra.verdict === 'REAL') badge.classList.add('badge-real');
                badge.textContent = extra.verdict === 'FAKE' ? 'TIN GI·∫¢' : 'TIN TH·∫¨T';
                extraDiv.appendChild(badge);
            }

            if (typeof extra.score === 'number') {
                const s = document.createElement('span');
                s.textContent = `ƒê·ªô tin c·∫≠y: ${(extra.score * 100).toFixed(1)}%`;
                extraDiv.appendChild(s);
            }

            row.appendChild(extraDiv);
        }

        messagesDiv.appendChild(row);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function clearMessages() {
        messagesDiv.innerHTML = '';
    }

    // ===== Sidebar: danh s√°ch conversation =====
    function renderConversationList() {
        convListEl.innerHTML = '';
        conversations
            .sort((a, b) => (b.updatedAtTs || 0) - (a.updatedAtTs || 0))
            .forEach(conv => {
                const item = document.createElement('div');
                item.className = 'conv-item';
                item.dataset.id = conv.id;
                if (String(conv.id) === String(conversationId)) {
                    item.classList.add('active');
                }

                const left = document.createElement('div');
                left.className = 'conv-left';

                const title = document.createElement('div');
                title.className = 'conv-title';
                title.textContent = conv.title || ('Cu·ªôc tr√≤ chuy·ªán ' + conv.id);

                const meta = document.createElement('div');
                meta.className = 'conv-meta';

                if (conv.lastVerdict) {
                    const badge = document.createElement('span');
                    badge.classList.add('badge');
                    if (conv.lastVerdict === 'FAKE') badge.classList.add('badge-fake');
                    else if (conv.lastVerdict === 'REAL') badge.classList.add('badge-real');
                    badge.textContent = conv.lastVerdict === 'FAKE' ? 'TIN GI·∫¢' : 'TIN TH·∫¨T';
                    meta.appendChild(badge);
                }

                const time = document.createElement('span');
                time.textContent = conv.updatedAt || '';
                meta.appendChild(time);

                left.appendChild(title);
                left.appendChild(meta);

                const delBtn = document.createElement('button');
                delBtn.className = 'conv-delete';
                delBtn.textContent = 'X√≥a';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();  // kh√¥ng trigger ch·ªçn cu·ªôc tr√≤ chuy·ªán
                    openDeleteModal(conv.id);
                });

                item.appendChild(left);
                item.appendChild(delBtn);
                item.addEventListener('click', () => selectConversation(conv.id));

                convListEl.appendChild(item);
            });
    }

    function upsertConversationFromResponse(data) {
        if (!data || !data.conversationId) return;
        const id = data.conversationId;
        const now = new Date();
        const nowStr = now.toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'});
        let conv = conversations.find(c => String(c.id) === String(id));
        if (!conv) {
            conv = {
                id,
                title: data.title || 'Cu·ªôc tr√≤ chuy·ªán ' + id,
                lastVerdict: data.verdict || null,
                updatedAt: nowStr,
                updatedAtTs: now.getTime()
            };
            conversations.push(conv);
        } else {
            conv.lastVerdict = data.verdict || conv.lastVerdict;
            conv.updatedAt = nowStr;
            conv.updatedAtTs = now.getTime();
        }
        renderConversationList();
    }

    async function selectConversation(id) {
        try {
            statusDiv.textContent = 'ƒêang t·∫£i l·ªãch s·ª≠ cu·ªôc h·ªôi tho·∫°i...';
            const res = await fetch(`/api/conversations/${id}?userId=${userId}`);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const data = await res.json();

            conversationId = data.id;
            clearMessages();

            (data.messages || []).forEach(m => {
                addMessage(m.sender, m.content, {
                    verdict: m.verdict,
                    score: m.score
                });
            });

            upsertConversationFromResponse({
                conversationId: data.id,
                verdict: data.lastVerdict,
                title: data.title
            });

            statusDiv.textContent = '';
        } catch (e) {
            console.error(e);
            statusDiv.textContent = 'Kh√¥ng t·∫£i ƒë∆∞·ª£c l·ªãch s·ª≠ cu·ªôc h·ªôi tho·∫°i.';
            showToast('L·ªói t·∫£i l·ªãch s·ª≠: ' + e.message, 'error');
        }
    }

    // L·∫•y danh s√°ch conversation ban ƒë·∫ßu
    async function loadConversations() {
        try {
            const res = await fetch(`/api/conversations?userId=${userId}`);
            if (!res.ok) {
                console.warn('Kh√¥ng load ƒë∆∞·ª£c danh s√°ch cu·ªôc h·ªôi tho·∫°i, HTTP', res.status);
                return;
            }
            const data = await res.json();

            conversations = (data || []).map(c => {
                const updatedAtTs = c.updatedAt ? new Date(c.updatedAt).getTime() : 0;
                return {
                    id: c.id,
                    title: c.title || ('Cu·ªôc tr√≤ chuy·ªán ' + c.id),
                    lastVerdict: c.lastVerdict || null,
                    updatedAt: formatTime(c.updatedAt),
                    updatedAtTs
                };
            });

            renderConversationList();

            if (conversations.length > 0) {
                const newest = conversations.sort((a,b) => b.updatedAtTs - a.updatedAtTs)[0];
                await selectConversation(newest.id);
            } else {
                statusDiv.textContent = 'Cu·ªôc tr√≤ chuy·ªán m·ªõi.';
            }

        } catch (e) {
            console.error('L·ªói loadConversations', e);
            showToast('Kh√¥ng t·∫£i ƒë∆∞·ª£c danh s√°ch cu·ªôc h·ªôi tho·∫°i.', 'error');
        }
    }

    newConvBtn.addEventListener('click', () => {
        conversationId = null;
        clearMessages();
        statusDiv.textContent = 'ƒê√£ t·∫°o cu·ªôc tr√≤ chuy·ªán m·ªõi. H√£y nh·∫≠p vƒÉn b·∫£n ƒë·ªÉ ph√¢n t√≠ch.';
        renderConversationList();
    });

    // ===== G·ª≠i TEXT (Enter g·ª≠i, Shift+Enter xu·ªëng d√≤ng) =====
    async function sendText() {
        const text = messageInput.value.trim();
        if (!text) {
            showToast('Vui l√≤ng nh·∫≠p n·ªôi dung b√†i vi·∫øt c·∫ßn ki·ªÉm tra.', 'error');
            return;
        }

        addMessage('USER', text);
        messageInput.value = '';
        autoResizeTextarea();

        statusDiv.textContent = 'ƒêang ph√¢n t√≠ch n·ªôi dung...';
        sendBtn.disabled = true;

        try {
            const res = await fetch('/api/chat/text', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId, conversationId, text })
            });

            if (!res.ok) {
                addMessage('MODEL',
                    '‚ö† Hi·ªán t·∫°i InSight AI ch∆∞a ph√¢n t√≠ch ƒë∆∞·ª£c n·ªôi dung (l·ªói k·∫øt n·ªëi m√¥ h√¨nh).',
                );
                statusDiv.textContent = 'Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c AI (HTTP ' + res.status + ').';
                showToast('M√°y ch·ªß ph√¢n t√≠ch ƒëang g·∫∑p s·ª± c·ªë.', 'error');
                return;
            }

            const data = await res.json();
            conversationId = data.conversationId ?? conversationId;

            const verdict = data.verdict;
            const score = data.score;

            const msgText = verdict === 'FAKE'
                ? 'TIN GI·∫¢. H√£y c·∫©n th·∫≠n khi chia s·∫ª n·ªôi dung n√†y.'
                : verdict === 'REAL'
                    ? 'K·∫øt qu·∫£: TIN TH·∫¨T / ƒê√ÅNG TIN C·∫¨Y.'
                    : `K·∫øt qu·∫£: ${verdict || 'Kh√¥ng x√°c ƒë·ªãnh'}`;

            addMessage('MODEL', msgText, { verdict, score });
            upsertConversationFromResponse(data);

            statusDiv.textContent = '';
        } catch (e) {
            console.error(e);
            addMessage('MODEL',
                '‚ö† Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi m√°y ch·ªß ph√¢n t√≠ch. Vui l√≤ng th·ª≠ l·∫°i sau.',
            );
            statusDiv.textContent = 'C√≥ l·ªói khi g·ªçi API ph√¢n t√≠ch.';
            showToast('L·ªói API: ' + e.message, 'error');
        } finally {
            sendBtn.disabled = false;
        }
    }

    function autoResizeTextarea() {
        messageInput.style.height = '24px';
        messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
    }

    messageInput.addEventListener('input', autoResizeTextarea);

    // Enter = g·ª≠i, Shift+Enter = xu·ªëng d√≤ng
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();   // kh√¥ng xu·ªëng d√≤ng
            sendText();
        }
    });

    sendBtn.addEventListener('click', sendText);

    // ===== G·ª≠i FILE .docx =====
    attachBtn.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', async () => {
        const file = fileInput.files[0];
        if (!file) return;

        const lower = file.name.toLowerCase();
        if (!lower.endsWith('.docx')) {
            showToast('Ch·ªâ cho ph√©p g·ª≠i file .docx', 'error');
            fileInput.value = '';
            return;
        }

        addMessage('USER', `ƒê√£ t·∫£i l√™n file: ${file.name}`);
        statusDiv.textContent = 'ƒêang upload & ph√¢n t√≠ch file Word...';

        const formData = new FormData();
        formData.append('userId', userId);
        if (conversationId != null) {
            formData.append('conversationId', conversationId);
        }
        formData.append('file', file);

        try {
            const res = await fetch('/api/chat/file', {
                method: 'POST',
                body: formData
            });

            if (!res.ok) {
                addMessage('MODEL',
                    '‚ö† Hi·ªán t·∫°i InSight AI ch∆∞a ph√¢n t√≠ch ƒë∆∞·ª£c file (l·ªói k·∫øt n·ªëi m√¥ h√¨nh).',
                );
                statusDiv.textContent = 'Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c AI (HTTP ' + res.status + ').';
                showToast('M√°y ch·ªß ph√¢n t√≠ch ƒëang g·∫∑p s·ª± c·ªë.', 'error');
                return;
            }

            const data = await res.json();
            conversationId = data.conversationId ?? conversationId;

            const verdict = data.verdict;
            const score = data.score;
            const msgText = verdict === 'FAKE'
                ? `File "${file.name}" c√≥ d·∫•u hi·ªáu TIN GI·∫¢.`
                : verdict === 'REAL'
                    ? `File "${file.name}" c√≥ n·ªôi dung ƒê√ÅNG TIN.`
                    : `ƒê√£ ph√¢n t√≠ch file: ${file.name}`;

            addMessage('MODEL', msgText, { verdict, score });
            upsertConversationFromResponse(data);

            statusDiv.textContent = '';
            showToast('Ph√¢n t√≠ch file ho√†n t·∫•t.', 'success');
        } catch (e) {
            console.error(e);
            addMessage('MODEL',
                '‚ö† Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi m√°y ch·ªß ph√¢n t√≠ch. Vui l√≤ng th·ª≠ l·∫°i sau.',
            );
            statusDiv.textContent = 'L·ªói khi upload / ph√¢n t√≠ch file.';
            showToast('L·ªói upload: ' + e.message, 'error');
        } finally {
            fileInput.value = '';
        }
    });

    // ===== Toggle layout (ph√≥ng to / thu nh·ªè) =====
    toggleLayoutBtn.addEventListener('click', () => {
        appRoot.classList.toggle('sidebar-collapsed');
    });

    // ===== Modal x√≥a cu·ªôc h·ªôi tho·∫°i =====
    function openDeleteModal(id) {
        pendingDeleteId = id;
        confirmModal.classList.add('show');
    }

    function closeDeleteModal() {
        pendingDeleteId = null;
        confirmModal.classList.remove('show');
    }

    confirmCancel.addEventListener('click', closeDeleteModal);

    confirmOk.addEventListener('click', async () => {
        if (!pendingDeleteId) return;

        const id = pendingDeleteId;
        try {
            const res = await fetch(`/api/conversations/${id}?userId=${userId}`, {
                method: 'DELETE'
            });

            if (!res.ok) throw new Error('HTTP ' + res.status);

            // X√≥a kh·ªèi danh s√°ch conversation tr√™n giao di·ªán
            conversations = conversations.filter(c => +c.id !== +id);
            renderConversationList();

            // N·∫øu ƒëang ·ªü cu·ªôc h·ªôi tho·∫°i ƒë√≥ ‚Üí reset m√†n h√¨nh chat
            if (+conversationId === +id) {
                conversationId = null;
                clearMessages();
                statusDiv.textContent = "Cu·ªôc tr√≤ chuy·ªán m·ªõi.";
            }

            showToast("ƒê√£ x√≥a cu·ªôc h·ªôi tho·∫°i.", "success");

        } catch (e) {
            console.error(e);
            showToast("Kh√¥ng th·ªÉ x√≥a cu·ªôc h·ªôi tho·∫°i: " + e.message, "error");
        } finally {
            closeDeleteModal();
        }
    });

    // ===== Logout =====
    logoutBtn.addEventListener('click', () => {
        // X√≥a d·ªØ li·ªáu cu·ªôc h·ªôi tho·∫°i c·ª•c b·ªô nh∆∞ng gi·ªØ ng∆∞·ªùi d√πng ·ªü ch·∫ø ƒë·ªô 'guest'
        try {
            conversations = [];
            conversationId = null;
            clearMessages();
            renderConversationList();
            statusDiv.textContent = 'B·∫°n ƒë√£ ƒëƒÉng xu·∫•t (d·ªØ li·ªáu c·ª•c b·ªô ƒë√£ xo√°). ƒêƒÉng nh·∫≠p l·∫°i d∆∞·ªõi d·∫°ng Kh√°ch.';
            localStorage.setItem('insight_user', JSON.stringify({ id: 'guest', username: 'Kh√°ch' }));
            showToast('ƒê√£ ƒëƒÉng xu·∫•t. B·∫°n ƒëang ·ªü ch·∫ø ƒë·ªô Kh√°ch.', 'success');
            // reload ƒë·ªÉ l√†m m·ªõi state ·ª©ng d·ª•ng
            window.location.reload();
        } catch (e) {
            console.error('L·ªói khi logout:', e);
            showToast('L·ªói khi ƒëƒÉng xu·∫•t: ' + e.message, 'error');
        }
    });

    // ===== Kh·ªüi t·∫°o =====
    addMessage(
        'MODEL',
        'Xin ch√†o üëã. M√¨nh l√† InSight AI. H√£y d√°n ƒëo·∫°n tin / b√†i b√°o ho·∫∑c t·∫£i l√™n file Word (.docx) ƒë·ªÉ ki·ªÉm tra Fake/Real v√† hi·ªÉu r√µ h∆°n v·ªÅ n·ªôi dung nh√©!'
    );

    loadConversations();
</script>
</body>
</html>
